Thie is a project that add some additional functions to xv6-system.

Lab 1: System calls and scheduler

Handed out Monday, Jan. 18, 2016
Due Friday, Jan. 30, 2016 (8 pm)

Introduction

There are two parts to this assignment: (1) Add a system call to xv6, and (2) Change the scheduler to use lottery scheduling.

Part 0: Setup and getting started

Please follow the setup instructions on the class webpage to get xv6 downloaded, installed and working with qemu and gdb. You may find it helpful to go through this optional xv6/JOS pre-lab

Part 1: Add a new system call

In this part of the assignment, you need to understand the system call implementation and add a new system call. Repeating from the optional lab:
Open two terminal windows. In one, enter make qemu-gdb (or make qemu-nox-gdb). This starts up QEMU, but QEMU stops just before the processor executes the first instruction and waits for a debugging connection from GDB. In the second terminal, from the same directory you ran make, run gdb. (Briefly, gdb -q -iex "set auto-load safe-path /home/csprofs/nael/xv6-master/" . Change the last part to your path to the xv6 directory. You should see something like this,

sledge% gdb
GNU gdb (GDB) 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
+ target remote localhost:26000
The target architecture is assumed to be i8086
[f000:fff0] 0xffff0:ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb) 
Now set a breakpoint on exec() by typing break exec in the gdb window type continue You should see something like:

(gdb) cont
Continuing.
[New Thread 2]
[Switching to Thread 2]
The target architecture is assumed to be i386
=> 0x80100af8 :push   %ebp

Breakpoint 1, exec (path=0x1c "/init", argv=0x8dfffe98) at exec.c:12
12{
(gdb)
Here we stop execution after the OS is initialized at the stage where it is starting the first process (init). If you type continue again, you will break again as follows:

gdb) cont
Continuing.
[Switching to Thread 1]
=> 0x80100af8 :push   %ebp

Breakpoint 1, exec (path=0x8c3 "sh", argv=0x8dffee98) at exec.c:12
12{
As you can see, at this stage, init started a shell process which is the xv6 shell we get when the OS boots. If you continue again, gdb will not return since it is waiting for a command to be started in the shell. Switch to the other window and try typing a command (fore example, cat README) at which time you will get another break as the shell forks then execs the cat program. Feel free to look around at the program when it breaks to see how we reach the system call which should give you ideas about how to add one.

Assignment for this part

: Add a new system call that returns a count of the total number of system calls that a process has done so far.
Part 2: Implement lottery scheduling

In this part of the assignment, you will implement lottery scheduling as per the OSDI 1994 paper we read in class. Implement only basic operation (no ticket transfers, compensation tickets, etc...). It is up to you to design the interface to assign the number of tickets, but it should be sufficient to illustrate that the scheduler works. To get started, look at the file proc.c In there you will find a simple round robin CPU scheduler implemented. You should change the logic there to use lottery scheduling. However, you also need to create the data structures to keep track of tickets.
